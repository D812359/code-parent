1、Synchronized的作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。

2、如果说一段代码，被synchronized所修饰，那么被修饰的这段代码就会以原子的方式执行，
而多个线程在执行这段代码的时候不会相互干扰，因为多个线程执行不会同时执行这段代码。

3、那么具体是如何做到不会同时执行呢？它们怎么知道已经有一个线程执行那我就不执行呢？
它们会有一把锁，这把锁在第一个线程执行这段代码的时候就已经拿到这把锁，一旦拿到之后，就会独占这把锁；
直到这个方法结束或者一定条件之后，它才会释放这把锁；在这把锁释放之前，其他的线程只能是等待阻塞，直到
这把锁释放了，其他的线程才可以去执行这段代码。

4、不使用并发手段，两个线程同时 a++,最后结果比预计少。
原因：a++ 看上去是一个操作，实际包含了三个动作：
1)、读取a
2)、将a加一
3)、将a值写入内存
在多线程的情况下呢任何一步执行完都有可能被打断，都有可能轮到第二个线程去执行；
考虑一种情况，假设现在a=9，线程一读取到a的值为9，然后加一 把a变为10；
但是还没来得及写入内存，第二个线程也进入到这个方法，第二个线程读取的a值仍然是9，线程二计算之后a也是10，接下来会把10写入内存；
就是因为这样的原因在多线程的情况下，出现不符合我们的预期这种行为我们称之为 线程不安全。

5、Synchronized的两个用法。
1)、对象锁：包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）；
2)、类锁：指synchronized修饰静态的方法或指定锁为Class对象。

6、类锁用法。
概念：Java类可能有很多个对象，但只有1个Class对象
本质：所以所谓的类锁，不过是Class对象的锁而已；
由于class对象只有一个，所以不同线程之间无论是哪一个实例过来的，它都只能获取到唯一的一个锁（不同的实例之间会互斥，只能有一个线程在同一时刻访问这一个被类锁锁住的方法）。
与对象锁的区别：
类锁：即便是不同的Runnable实例，这个线程所对应的类锁仍然只有一个，只能有一个可以运行；
对象锁：如果是不同的实例创建出来，互相锁是不影响的，你也可以运行，我也可以运行，我们可以同时运行。
形式1：synchronized加在static方法上
形式2：synchronized (*.class)代码块

7、多线程访问同步方法的7种情况。
1)、两个线程同时访问一个对象的同步方法
参考 SynchronizedObjectMethod3.class; 同一个实例，锁是同一把锁；

2)、两个线程同时访问两个对象的同步方法
参考 SynchronizedObjectCodeBlock2.class;同时并行执行，锁对象不是同一个，互不干扰；

3)、两个线程访问的是synchronized的静态方法
参考 SynchronizedClassStatic4.class; 会一个一个执行，锁生效；

4)、同时访问同步方法与非同步方法
参考 SynchronizedYesAndNo6.class;
同时开始，同时结束；synchronized关键字，只作用于指定的那个方法中，
对于其他没有加synchronized关键字的方法，根本不受到影响。

5)、访问同一个对象的不同的普通同步方法
参考 SynchronizedDifferentMethod7.class;
串行执行，对于同一个实例来讲，两个方法拿到的this是一样的，所以这两个方法没办法同时运行；

6)、同时访问静态synchronized和非静态synchronized方法
参考 SynchronizedStaticAndNormal8.class;
同时运行，因为指定的锁对象不是同一个锁；

7)、方法抛出异常后，会释放锁
参考 SynchronizedException9.class

总结：
1)、一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应第1、5种情况）；
2)、每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是*.class
以及synchronized修饰的是static方法的时候，所有对象共用同一把锁（对应第2,3,4,6种情况）；
3)、无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应第7种情况）。
注：目前进入到被synchronized修饰的方法，而在这个方法里面去调用另外一个没有被synchronized修饰的方法，
那么这个时候是不线程安全的；因为一旦出了本方法，到了另一个方法中，由于另一个方法没有被synchronized修饰，
所以说这个方法可以同时被多个线程进行访问的。

8、Synchronized性质。
1)、可重入：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。
好处：避免死锁、提升封装性
通过10-12.java 的验证，可以证明Synchronized关键字的粒度肯定不是调用层面的，通过查阅发现粒度范围是线程范围；
在同一个线程中，如果已经拿到了一把锁，然后想接着使用这把锁，去访问其他的方法，或者是访问其他类的方法，只要它需要
的锁依然是我手中的这把锁，那么这个可重入的性质就会被激发出来吗，就不在需要显示的释放锁或者重新获取锁。

2)、不可中断：一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。
如果别人永远不释放锁，那么我只能永远的等下去。

9、Synchronized原理
9.1 加锁和释放锁的原理：深入JVM看字节码
MonitorEnter（加锁）：在执行是会让对象的锁计数加1，每个对象都和一个Monitor相关联，
而一个Monitor的lock锁只能被一个线程在同一时间获得，一个线程在尝试获得与这个对象关联的Monitor所有权时，
只会发生以下三种情况之一：
1)、如果monitor计数器为0，这意味着目前还没有被获得，所以这个线程会立刻获得，然后把计数器加1，
一旦加1之后，别人在想进来就会看到这个信号，就知道它已经被别人所持有了；所以加1也就意味着当前线程是这个Monitor的所有者；
2)、如果说monitor已经拿到了锁的所有权，又重入了，这样会导致计数器累加，就是在加1，变成2，随着重入的次数会逐渐的往上走；
3)、如果monitor被其他线程所持有了，而我去获取它的时候，只能得到现在获取不了的信号，我就会进入阻塞状态；直到monitor计数器变为0
才会再次去尝试获取锁。

MonitorExit（释放）：作用是释放对于monitor的所有权，也就是释放锁（前提是已经拥有这个锁的所有权）。
释放的过程就是 将monitor计数器减1，如果减为0了，那就意味着当前线程不在拥有对monitor的所有权了，通俗讲就是解锁；
如果说减完之后不是0，那意味着刚才是可重入进来的，当前线程还继续持有这把锁。

9.2 可重入原理：加锁次数计数器
每个对象都自动含有一把锁，JVM负责跟踪对象被加锁的次数；
线程第一次给对象加锁的时候，计数变为1。每当这个相同的线程再此对象上再次获得锁时，计数会递增。
每当任务离开时，计数递减，当计数为0的时候，锁被完全释放。

9.3 可见性原理：Java内存模型(JMM)
本地内存：保存的变量是一个副本，也就是说是把主内存中的变量复制一份放到，本地内存。
这样的好处就是可以加速程序运行。
线程A 向 线程B 发送数据的步骤：
首先本地内存A会把自己修改过的变量内容放到主内存中，然后线程B从主内存中读取，整个过程是由JMM控制;
JMM正是通过控制主内存与每个线程的本地内存之间的交互，来为我们的提供了内存可见性的保证。

Synchronized是如何做到可见性的实现的？
一旦一个代码块或者方法被我们Synchronized关键字所修饰，那么它在执行完毕之后，
被锁住的对象所做的任何修改都要在释放锁之前从线程内存写回到主内存当中，就是说不会存在一种情况叫做线程内存和主内存内容不一致；

10、Synchronized缺陷
1)、效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。

a)、锁的释放情况少：当一个线程获得了对应的Synchronized锁的时候，并且在执行这段代码的时候，其他线程如果也想得到这把锁，只能等当前线程释放；
而只有两种情况当前线程才会释放锁：1、线程执行完这段代码；2、执行到一半发生异常
b)、试图获得锁时不能设定超时：只能干巴巴的等待
c)、不能中断一个正在试图获得锁的线程：相比之下lock有中断能力

2)、不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的；
3)、无法知道是否成功获取到锁


