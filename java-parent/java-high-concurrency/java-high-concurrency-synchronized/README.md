1、Synchronized的作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。

2、如果说一段代码，被synchronized所修饰，那么被修饰的这段代码就会以原子的方式执行，
而多个线程在执行这段代码的时候不会相互干扰，因为多个线程执行不会同时执行这段代码。

3、那么具体是如何做到不会同时执行呢？它们怎么知道已经有一个线程执行那我就不执行呢？
它们会有一把锁，这把锁在第一个线程执行这段代码的时候就已经拿到这把锁，一旦拿到之后，就会独占这把锁；
直到这个方法结束或者一定条件之后，它才会释放这把锁；在这把锁释放之前，其他的线程只能是等待阻塞，直到
这把锁释放了，其他的线程才可以去执行这段代码。

4、不使用并发手段，两个线程同时 a++,最后结果比预计少。
原因：a++ 看上去是一个操作，实际包含了三个动作：
1)、读取a
2)、将a加一
3)、将a值写入内存
在多线程的情况下呢任何一步执行完都有可能被打断，都有可能轮到第二个线程去执行；
考虑一种情况，假设现在a=9，线程一读取到a的值为9，然后加一 把a变为10；
但是还没来得及写入内存，第二个线程也进入到这个方法，第二个线程读取的a值仍然是9，线程二计算之后a也是10，接下来会把10写入内存；
就是因为这样的原因在多线程的情况下，出现不符合我们的预期这种行为我们称之为 线程不安全。

5、Synchronized的两个用法。
1)、对象锁：包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）；
2)、类锁：指synchronized修饰静态的方法或指定锁为Class对象。

6、类锁用法。
概念：Java类可能有很多个对象，但只有1个Class对象
本质：所以所谓的类锁，不过是Class对象的锁而已；
由于class对象只有一个，所以不同线程之间无论是哪一个实例过来的，它都只能获取到唯一的一个锁（不同的实例之间会互斥，只能有一个线程在同一时刻访问这一个被类锁锁住的方法）。
与对象锁的区别：
类锁：即便是不同的Runnable实例，这个线程所对应的类锁仍然只有一个，只能有一个可以运行；
对象锁：如果是不同的实例创建出来，互相锁是不影响的，你也可以运行，我也可以运行，我们可以同时运行。
形式1：synchronized加在static方法上
形式2：synchronized (*.class)代码块

7、多线程访问同步方法的7种情况。
1)、两个线程同时访问一个对象的同步方法
参考 SynchronizedObjectMethod3.class; 同一个实例，锁是同一把锁；

2)、两个线程同时访问两个对象的同步方法
参考 SynchronizedObjectCodeBlock2.class;同时并行执行，锁对象不是同一个，互不干扰；

3)、两个线程访问的是synchronized的静态方法
参考 SynchronizedClassStatic4.class; 会一个一个执行，锁生效；

4)、同时访问同步方法与非同步方法
参考 SynchronizedYesAndNo6.class;
同时开始，同时结束；synchronized关键字，只作用于指定的那个方法中，
对于其他没有加synchronized关键字的方法，根本不受到影响。

5)、访问同一个对象的不同的普通同步方法
参考 SynchronizedDifferentMethod7.class;
串行执行，对于同一个实例来讲，两个方法拿到的this是一样的，所以这两个方法没办法同时运行；

6)、同时访问静态synchronized和非静态synchronized方法
参考 SynchronizedStaticAndNormal8.class;
同时运行，因为指定的锁对象不是同一个锁；

7)、方法抛出异常后，会释放锁
参考 SynchronizedException9.class
