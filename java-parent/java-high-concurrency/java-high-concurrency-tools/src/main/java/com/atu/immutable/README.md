6、以不变应万变：final关键字和不变性
6.1 什么是不变性(Immutable)
如果对象在被创建后，状态就不能被修改，那么它就是不可变的；

例子：person对象，age和name都不能在变
好处：具有不变性的对象一定是线程安全的，我们不需要对其采取任何额外的安全措施，也能保证线程安全。

6.2 final的作用
6.2.1 早期
1)、锁定
2)、效率：早起的Java实现版本中，会将final方法转为内嵌调用

6.2.2 现在
1)、类防止被继承、方法防止被重写、变量防止被修改
2)、天生是线程安全的，而不需要额外的同步开销

6.3 3种用法：修饰变量、方法、类
6.3.1 final修饰变量——三种变量
1)、含义：被final修饰的变量，意味着值不能被修改。如果变量是对象，那么对象的引用不能变，但是对象自身的内容依然可以变化；

a、final instance variable(类中的final属性) FinalVariableDemo.java
 第一种是在声明变量的时候直接在等号右边赋值： final int age = 18;
 第二种就是在构造函数中赋值
 第三就是在类的初始代码块中赋值(不常用)
如果不采用第一种赋值方法，那么就必须在第2、3中挑一个来赋值，而不能不赋值，这是final语法所规定的的。
b、final static variable(类中的static final属性)
 两个赋值时机：除了在声明变量的等号右边直接赋值外，static final变量还可以用static初始代码块赋值，
 但是不能用普通的初始代码块赋值

c、final local variable(方法中的final变量)
 和前面两种不同，由于这里的变量是在方法里的，所以没有构造函数，也不存在初始代码块。
 首先，它不规定赋值时机，只要求在使用前必须赋值，这和方法中的非final变量的要求是一样的。

2)、final修饰变量：赋值时机
属性被声明为final后，该变量则只能被赋值一次，且一旦被赋值，final的变量就不能再被改变，无论如何也不会变。

3)、为什么要规定赋值时机？
如果初始化不赋值，后续赋值，就是从Null编程你的赋值，这样就违反了final不变的原则了。

6.3.2 final修饰方法
1)、构造方法不允许final修饰
2)、不可被重写，也就是不能被override，即便是子类有同样名字的方法，那也不是override，这个和static方法是一个道理；

引申：static方法不能被重写，但是可以再子类定义一个重名方法
这是因为static变量在创建的时候，就已经绑定了这个方法，而不是后期动态绑定的，看上去是重写了，其实不是；
只是属于子类的跟父类没关系。
FinalMethodDemo.java

6.3.3. final修饰类
不可被继承.
例如：典型的String类就是final的，我们从没见过哪个类是继承String类的。

6.4 注意点
1)、final修饰对象的时候，只是对象的引用不可变，而对象本身的属性是可以变化的。
2)、final使用原则：良好的编程习惯

6.5 不变性和final的关系(*)
不变性并不意味着，简单地用final修饰就是不可变
 1)、对于基本数据类型而言，确实被final修饰后就具有不变性
 2)、但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才可以；被final修饰之后仅仅代表引用不可变，而对象里面的内容是可变的；

如何利用final实现对象不可变呢？
 1)、把所有的属性都声明为final？
  错误，如果有个属性是对象的话，那么即便用final修饰，它只是对象引用不可变，而对象本身还可变。
  TestFinal.java
 2)、一个属性是对象类型的不可变对象的正确例子
 
总结，满足以下条件时，对象才是不可变的：
1)、对象创建后，其状态就不能修改
2)、所有属性都是final修饰的
3)、对象创建过程中没有发生逸出

6.6 把变量写在线程内部——栈封闭
我们如果往方法里新建局部变量，实际上缴就是存储在每个线程私有的栈空间；
而每个栈的栈空间是不能被其他线程所访问到的，所以不会有线程安全问题。这就是著名的"栈封闭"技术。是"线程封闭"技术的一种情况。
StackConfinement.java

6.7 面试题
真假美猴王