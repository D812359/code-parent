3、不可不说的“锁”事【种类繁多，如何一一突破？】
3.1、Lock接口
3.1.1 简介、地位、作用
1)、锁是一种工具，用于控制对共享资源的访问。
2)、Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同。
3)、Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的。
4)、Lock接口最常见的实现类是ReentrantLock
5)、通常情况下，Lock只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可允许并发访问，比如ReadWriteLock里面的ReadLock。

3.1.2 为什么synchronized不够用？为什么需要Lock？
1)、效率低：锁的释放情况少（两种方式）、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程；
2)、不够灵活(读写锁更灵活)：加锁和释放的实际单一，每个锁仅有单一的条件（某个对象），可能是不够的
3)、无法知道是否成功获取到锁

3.1.3 方法介绍
在Lock中声明了四个方法来获取锁：
lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()
3.1.4、四个方法的区别
1)、lock MustUnlock.java
a、lock()就是最普通的获取锁。如果锁已被其他线程获取，则进行等待；
b、Lock不会像synchronized一样在异常时自动释放锁；
c、因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放；
d、lock()方法不能被中断，这会带来很大的隐患：一旦陷入死锁，lock()就会陷入永久等待
2)、tryLock
a、tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，并且返回true，否则返回false，代表获取锁失败；
b、相比于lock，这样恶毒方法显然功能更强大了，我们可以根据是否能获取到锁来决定后续程序的行为；
c、该方法会立即返回，即便在拿不到锁时不会一直在那等；

3)、tryLock(long time, TimeUnit unit)：超时就放弃


3.1.4 可见性保证

3.2、锁的分类
3.3、乐观锁和悲观锁
3.4、可重入锁和非可重入锁，以ReentrantLock为例(*)
3.5、公平锁和非公平锁
3.6、共享锁和排它锁：以ReentrantReadWriteLock读写锁为例(*)
3.7、自旋锁和阻塞锁
3.8、可中断锁：顾名思义就是可以响应中断的锁
3.9、锁优化