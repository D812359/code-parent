玩转Java并发工具，精通JUC，成为并发多面手
Java并发成神之路——JUC全方位详解：
https://naotu.baidu.com/file/89fb28b05e3395800f9dc2d332d2b198?token=9b45e08e55281667

1、线程池————治理线程的最大法宝
1.1 线程池的自我介绍
1.1.1 线程池的重要性
1.1.2 什么是"池"？
1.1.3 为什么要使用线程池？
1.1.4 线程池的好处
1.1.5 线程池适用的场合

1.2 创建和停止线程池
1.2.1 线程池构造函数的参数
1.2.2 添加线程规则
1.2.3 线程池应该手动创建还是自动创建？
1.2.4 线程池里的线程数量设定多少比较合适？
1.2.5 常见线程池的特点
1.2.6 阻塞队列分析
1.2.7 停止线程池的正确方法 ShutDown.java

1.3 常见线程池的特点和用法

1.4 任务太多，怎么拒绝？
1.4.1 拒绝时机
1.4.2 4种拒绝策略

1.5 钩子方法，给线程池加点料
1.5.1 在每个任务执行前后做点事情

1.6 实现原理，源码分析
1.6.1 线程池组成部分

1.6.2 Executor家族？

1.7 线程池的状态

1.8 使用线程池的注意点

2、ThreadLocal
两大使用场景————ThreadLocal的用途
典型场景1：每个线程需要一个独享的对象(通常是工具类，典型需要使用的类有SimpleDateFormat和Random)；

典型场景2：每个线程内需要保存全局变量(例如在拦截器中获取用户信息)，可以让不同方法直接使用，避免参数传递的麻烦；

3、不可不说的“锁”事【种类繁多，如何一一突破？】
3.1、Lock接口
3.2、锁的分类
3.3、乐观锁和悲观锁
3.4、可重入锁和非可重入锁，以ReentrantLock为例(*)
3.5、公平锁和非公平锁
3.6、共享锁和排它锁：以ReentrantReadWriteLock读写锁为例(*)
3.7、自旋锁和阻塞锁
3.8、可中断锁：顾名思义就是可以响应中断的锁
3.9、锁优化

4、atomic包【一刻也不能分割】
4.1、什么是原子类，有什么作用？
4.2、6类原子类纵览
4.3、Atomic*基本类型原子类，以AtomicInteger为例
4.4、Atomic*Array数组类型原子类
4.5、Atomic*Reference引用类型原子类
4.6、把普通变量升级为原子类，用AtomicIntegerFieldUpdater升级原有变量
4.7、Adder累加器
4.8、Accumulator累加器

5、CAS原理
5.1、什么是CAS
5.2、案例演示
5.3、应用场景
5.4、以AtomicInteger为例，分析在Java中是如何利用CAS实现原子操作的？
5.5、缺点

6、以不变应万变：final关键字和不变性
6.1 什么是不变性(Immutable)
6.2 final的作用
6.3 3种用法：修饰变量、方法、类
6.4 注意点
6.5 不变性和final的关系

栈封闭