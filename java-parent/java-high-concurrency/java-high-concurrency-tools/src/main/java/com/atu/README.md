玩转Java并发工具，精通JUC，成为并发多面手
Java并发成神之路——JUC全方位详解：
https://naotu.baidu.com/file/89fb28b05e3395800f9dc2d332d2b198?token=9b45e08e55281667

1、线程池————治理线程的最大法宝
1.1 线程池的自我介绍
1.1.1 线程池的重要性
1.1.2 什么是"池"？
软件中的"池"，可以理解为计划经济；我们的系统资源是有限的，比方说我们只有10个线程，我们就创造10个线程的线程池；
但是我们的任务可能非常多，比方说1000个任务；但是资源只有这10个线程，那么就要把这1000任务放到这10个线程里面去，我慢慢去执行。
还有一个好处就是，有了这10个线程之后，就不需要在创建更多的线程了，因为创建线程也需要花费资源，这10个线程，我可以把总量控制住，
而且可以复用每一个线程。
所以总体来讲，线程池有两个好处：1、复用线程；2、可以控制资源总量。

如果不使用线程池，每一个任务都要新开一个线程处理：
1)、一个线程：EveryTaskOneThread；b、for循环创建线程：ForLoop
当任务数量上升到1000。。。
这样开销太大（尤其是内存），我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的的开销问题。

1.1.3 为什么要使用线程池？
2)、反复创建线程开销大；b、过多的线程会占用太多内存；
解决以上两个问题的思路：
a)、用少量的线程————避免内存占用过多；
b)、让这部分线程都保持工作，且可以反复执行任务————避免生命周期的损耗；

1.1.4 线程池的好处
1)、加快响应速度；
2)、可以更加合理的利用CPU和内存
3)、可以统一管理资源

1.1.5 线程池适用的场合
1)、服务器接受到大量请求时，使用线程池计数是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率；
2)、实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理；

1.2 创建和停止线程池
1.2.1 线程池构造函数的参数
![binaryTree](../atu/img/线程池构造函数的参数.png "binaryTree")
1)、corePoolSize指的是核心线程数：线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，在创建新线程去执行任务。
2)、maxPoolSize：线程池有可能会在核心线程数的基础上，增加额外一些线程，但是这些新增加的线程数有一个上限，这就是最大量maxPoolSize；
3)、keepAliveTime：如果说线程池当前的线程数多于corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止————相当于回收；
默认情况下回收的是多于corePoolSize的数量会被回收，除非修改allowCoreThreadTimeOut为true，这样会把核心的数量也回收，但是通常不采用。
4)、ThreadFactory：新线程都是有ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。
如果自己指定ThreadFactory，那么就可以改变线程名，线程组，优先级，是否是守护线程等。
5)、workQueue：工作队列，有3种最常见的队列类型：
 a、直接交换——SynchronousQueue：如果说任务不会特别多，我们只是把任务通过这个队列做一下简单的中转，交给线程去处理的话，那么久可以使用这个队列；
 b、无界队列——LinkedBlockingQueue：不会被塞满，可以防止流量突增，但是缺点是如果处理不及时可能会造成内存浪费或者OOM异常；
 c、有界的队列：ArrayBlockingQueue：可以设置队列大小，此时线程的maxPoolSize就有意义了。

1.2.2 添加线程规则
![binaryTree](../atu/img/添加线程规则.png "binaryTree")

1)、如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务；
2)、如果线程等于(或大于)corePoolSize但少于maximumPoolSize，则将任务放入队列；
3)、如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务；
4)、如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务；

举个例子：线程池：核心池大小为5，最大池大小为10.队列为100。
因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100；
当队列已满时，将创建最新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝。

总结：增减线程的特点
1)、通过设置corePooSize和maximumPoolSize相同，就可以创建固定大小的线程池；
2)、线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它；
3)、通过设置maximumPoolSize为很高的值，例如Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务；
4)、只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列(例如LinkedBlockingQueue)，那么线程数就不会超过corePoolSize。

1.2.3 线程池应该手动创建还是自动创建？
手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。
1)、自动创建线程池(也就是直接调用JDK封装好的构造函数)可能带来哪些问题？
a、newFixedThreadPool
 由于传进去的LinkedBlockingQueue 是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM；
 

1.2.3 线程池里的线程数量设定多少比较合适？

1.2.4 停止线程池的正确方法

1.3 常见线程池的特点和用法

1.4 任务太多，怎么拒绝？

1.5 钩子方法，给线程池加点料

1.6 实现原理，源码分析

1.7 使用线程池的注意点