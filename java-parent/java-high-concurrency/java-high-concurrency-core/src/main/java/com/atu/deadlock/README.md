1、写一个必然死锁的例子
2、发生死锁必须满足那些条件？
3、如何定位死锁？
4、有哪些解决死锁问题的策略？
5、讲讲经典的哲学家就餐问题
6、实际工程中如何避免死锁？
7、什么是活跃性问题？活锁、饥饿和死锁有什么区别？

死锁————从产生到消除
1、死锁是什么？有什么危害？
一定是发生在并发中；
互不相让：当两个（或更多）线程（或进程）相互持有对方所要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁。
![binaryTree](../img/死锁.png "binaryTree")
![binaryTree](../img/多线程造成死锁.png "binaryTree")

2、死锁的影响
死锁的影响在不同的系统中是不一样的，这取决于系统对死锁的处理能力
1)、数据库中：可以检测并放弃事务
2)、JVM中：无法自动处理

3、死锁发生几率不高但危害大
1)、不一定发生，但是遵守“墨菲定律”
2)、一旦发生，多是高并发场景，影响用户多
3)、整个系统崩溃、子系统崩溃、性能降低
4)、压力测试无法找出所有潜在我的死锁

4、发生死锁的例子
1)、最简单的情况：MustDeadLock.java
a、当类的对象flag=1时(r1)，先锁定o1，睡眠500ms，然后锁定o2；
b、而r1在睡眠的时候另一个flag = 0的对象(r2)线程启动，先锁定o2，睡眠500ms，等待r1释放O1；
c、r1、r2相互等待，都需要对方锁定的资源才能继续执行，从而死锁。

2)、实际生产中的例子：转账
TransferMoney.java

3)、模拟多个随机转账
MultiTransferMoney.java

5、死锁发生的4个必要条件
1)、互斥条件
2)、请求与保持条件：第一个线程去请求第二把锁，但是同时保持第一把锁
3)、不剥夺条件
4)、循环等待条件
四个缺一不可。

6、如何定位死锁？
jstack命令：
1)、首先使用命令行查看到java的pid：jps
2)、jstack pid