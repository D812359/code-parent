线程8大核心基础
1、实现多线程的方法到底有1种还是2种还是4种？
正确的方法：2种。
一种是继承Thread类，另一种方法是声明一个实现Runnable接口。
1.1 两种方法对比
实现Runnable接口更好：
1）、从代码架构角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦，用Runnable对象可以实现解耦。
2）、如果说继承Thread类实现的话，每次我们想新建一个任务只能去新建一个独立的线程，
而新建一个独立的线程的损耗是比较大的：需要创建、执行、销毁；而如果使用Runnable,
我们就可以利用后续的线程池之类的工具，而利用这样的工具就可以大大减小这些创建线程和
销毁线程所带来的损耗————资源的节约上
3)、继承了Thread之后，由于Java不支持双继承导致这个类就无法继承其他的类了，这大大限制了我们的可扩展性。

两种方法的本质对比：run()方法
继承Thread（一旦子类重写了父类的方法，也就意味着父类方法直接被覆盖，被抛弃，它将不会被这次的调用所采纳）：run()整个都被重写;
实现Runnable：最终调用target.run();

1.2 思考题：同时用两种方法会怎么样？
BothRunnableThread.java
从面向对象的思想去考虑
由于已经重写了父类的run()方法，所以即便我们传入了Runnable对象，也不会执行父类的方法。

总结：准确的讲，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式：
方法一：实现Runnable接口的run()方法，并把Runnable实例传给Thread类
方法二：重写Thread的run方法（继承Thread类）
还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。

1.3 典型错误观点分析
a、"线程池创建线程也算是一种新建线程的方式"
ThreadPool5.java 是通过new Thread();实现的

b、"通过Callable和FutureTask创建线程，也算是一种新建线程的方法"
实现了Runnable接口，本质离不开Runnable

c、"无返回值的是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式"
本质没有创新，离不开Runnable接口
d、定时器
DemoTimmerTask.java 表面现象，也是离不开那两种方法
e、匿名内部类
AnonymousInnerClassDemo.java
f、Lambda表达式
Lambda.java

总结：多线程的实现方式，在代码种写法千变万化，但其本质万变不离其宗。
本质就是通过各种各样的包装，比如通过线程池包装、定时器包装，但是其本质都是那两种方式。

（*）面试问题：有多少种实现多线程的方式？
 答题思路，有以下5点：  
从不同的角度看，会有不同的答案。 典型答案是两种，分别是实现Runnable接口和继承Thread类；
但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，
run方法的代码如下： 
@Override 
public void run () {
    if (target != null) {
         target.run();
    }
}
方法一和方法二，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。
这两个方法的最主要区别在于run()方法的内容来源： 
方法一：最终调用target.run(); 方法二：run()整个都被重写；
然后具体展开说其他方式； 还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。  
结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现：第一种是重写run方法；
第二种实现Runnable接口的run方法，然后再把该runnable实例传给Thread类。
除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是它们的本质都逃不出刚才所说的范围。

2、怎样才是正确的线程启动方式？
2.1 start()和run()的比较
2.1.1 start()方法含义：
启动新线程————主线程会请求jvm运行线程，线程何时能运行由线程调度器决定。
start方法会让两个线程同时运行，第一个就是主线程，第二个才是刚刚创建的子线程；

准备工作————调用start()方法只是告诉jvm在合适的时候来启动；
第二个就是新线程需要准备工作才能运行，首先它会让自己处于就绪状态，
就绪状态指的是我已经获取到除CPU以外的其他资源，比如说我已经设置了上下文、栈、线程状态以及PC(寄存器，PC指向了程序运行的位置)；

不能重复调用start():
CantStartTwice.java

start方法的执行流程是什么？ 
1、检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中或者已结束的线程，都不能再次启动，详见CantStartTwice类）
2、被加入线程组 
3、调用start0()方法启动线程 
注意点： start方法是被synchronized修饰的方法，可以保证线程安全；
由JVM创建的main方法线程和system组线程，并不会通过start来启动。

2.1.2 run()方法：
那两种方式：“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”。

（*）面试问题：一个线程两次调用start()方法会出现什么情况？为什么？
start()方法开始的时候就会对当前线程的状态进行一个检查，如果不符合规定（如果已经执行了start()方法）就会抛出异常；
线程的状态：new状态 -> runnable -> 结束。

（*）面试问题：既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？
因为调用start()方法才是真正意义上启动一个线程，它会去经历线程的各个生命周期；
而如果直接调用run()方法，它就是一个普通的方法而已，不会通过子线程去调用。

3、上山容易下山难————如何正确停止线程？（难点）
Java中停止线程的原则是什么？ 
在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止的线程自身拥有决定权（决定是否、以及何时停止），
这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。  任务和线程的启动很容易。在大多数时候,我们都会让它们运行直到结束,或者让它们自行停止。
然而,有时候我们希望提前结束任务或线程,或许是因为用户取消了操作,或者服务需要被快速关闭，或者是运行超时或出错了。 
要使任务和线程能安全、快速、可靠地停止下来,并不是一件容易的事。Java没有提供任何机制来安全地终止线程。
但它提供了中断( Interruption),这是一种协作机制,能够使一个线程终止另一个线程的当前工作。 
这种协作式的方法是必要的,我们很少希望某个任务、线程或服务立即停止,因为这种立即停止会使共享的数据结构处于不一致的状态。
相反,在编写任务和服务时可以使用一种协作的方式:当需要停止时,它们首先会清除当前正在执行的工作,然后再结束。
这提供了更好的灵活性,因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。 
生命周期结束(End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂,而这个在程序设计中非常重要的要素却经常被忽略。
一个在行为良好的软件与勉强运的软件之间的最主要区别就是,行为良好的软件能很完善地处理失败、关闭和取消等过程。
3.1 如何正确停止线程？
原理介绍：使用interrupt来通知，而不是强制
我们的线程和任务被创造并且启动之后，大部分情况下都是运行到结束的，自然停止；
但是在有些情况下需要用到停止————或许是用户主动取消、或许服务需要突然关闭以及运行超时或者出错线程也需要被停止；
Java语言没有一种机制来安全正确的停止线程，但是它提供了interrupt这是一种合作机制，也就是说我们用一个线程来通知另一个线程，让它停止当前的工作。
在Java中我们如果想停止一个线程，能做的最多的就是告诉它————该中断了；而被中断的线程本身，它自身拥有决定权，它不断能有决定何时去响应这个中断，
它还拥有最高决定权就是停不停止。

3.2 通常线程会在什么情况下停止？
1)、run()方法的所有代码都运行完毕了；
2)、有异常出现，并且方法中没有被捕获；

3.3 最佳实践：如何正确停止线程
3.3.1 通常线程会在什么情况下停止————普通情况
RightWayStopThreadWithoutSleep.java

3.3.2 线程可能被阻塞
RightWayStopThreadWithSleep.java

3.3.3 如果线程在每次迭代后都阻塞
RightWayStopThreadWithSleepEveryLoop.java 
不需要加入判断条件————Thread.currentThread().isInterrupted()

3.3.4 while内 try/catch 的问题：中断失效
CantInterrupt.java 
java语言在设计sleep()函数的时候，当它一旦响应中断，于是便会把线程的interrupted标记位给清除；
导致程序不能退出。

3.3.5 实际开发中的两种最佳实践
1)、优先选择：传递中断

处理中断的最好方法是什么？ RightWayStopThreadInProduct.java
优先选择在方法上抛出异常。
用throws InterruptedException标记你的方法，不采用try语句块捕获异常，以便于该异常可以传递到顶层，让run方法可以捕获这一异常，例如
void subTask() throws InterruptedException {
    sleep(delay);
}
由于run()方法内无法抛出checked Exception（只能用try catch），顶层的方法必须处理该异常，避免漏掉或者被吞掉的情况，增强了代码的健壮性。

2)、不想或无法传递：恢复中断
如果不想或无法传递InterruptedException （例如用run方法的时候，就不让该方法throws InterruptedException),
那么应该选择在catch子句中调用 Thread.currentThread().interrupt(); 来恢复设置中断状态，以便在后续的执行依然能够检查到刚才发生了中断。
RightWayStopThreadInProduct2.java

3)、不应屏蔽中断————禁止屏蔽

总结：为啥使用interrupt中断线程？
首先，被中断的线程自身拥有如何响应中断的权利，因为有些线程的某些代码是非常重要的，我们必须要等待这些线程处理完或者准备好之后，
由他们自己主动终止或者不理会，而不是粗鲁的使用stop()方法，这样使我们的线程代码在实际中更加安全，也完成了清理工作，数据的完整性也得到了保障。

3.4 停止线程的错误方法
3.4.1 被弃用的stop、suspend和resume方法

3.4.2 用volatile设置boolean标记位

4、线程的一生————6个状态（生命周期）

5、Thread类和Object类中的重要方法详解

6、线程的各个属性

7、未捕获异常如何处理？

8、双刃剑：多线程会导致的问题