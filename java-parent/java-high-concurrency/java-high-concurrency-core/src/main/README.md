线程8大核心基础
1、实现多线程的方法到底有1种还是2种还是4种？
正确的方法：2种。
一种是继承Thread类，另一种方法是声明一个实现Runnable接口。
1.1 两种方法对比
实现Runnable接口更好：
1）、从代码架构角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦，用Runnable对象可以实现解耦。
2）、如果说继承Thread类实现的话，每次我们想新建一个任务只能去新建一个独立的线程，
而新建一个独立的线程的损耗是比较大的：需要创建、执行、销毁；而如果使用Runnable,
我们就可以利用后续的线程池之类的工具，而利用这样的工具就可以大大减小这些创建线程和
销毁线程所带来的损耗————资源的节约上
3)、继承了Thread之后，由于Java不支持双继承导致这个类就无法继承其他的类了，这大大限制了我们的可扩展性。

两种方法的本质对比：run()方法
继承Thread（一旦子类重写了父类的方法，也就意味着父类方法直接被覆盖，被抛弃，它将不会被这次的调用所采纳）：run()整个都被重写;
实现Runnable：最终调用target.run();

1.2 思考题：同时用两种方法会怎么样？
BothRunnableThread.java
从面向对象的思想去考虑
由于已经重写了父类的run()方法，所以即便我们传入了Runnable对象，也不会执行父类的方法。

总结：准确的讲，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式：
方法一：实现Runnable接口的run()方法，并把Runnable实例传给Thread类
方法二：重写Thread的run方法（继承Thread类）
还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。

1.3 典型错误观点分析
a、"线程池创建线程也算是一种新建线程的方式"
ThreadPool5.java 是通过new Thread();实现的

b、"通过Callable和FutureTask创建线程，也算是一种新建线程的方法"
实现了Runnable接口，本质离不开Runnable

c、"无返回值的是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式"
本质没有创新，离不开Runnable接口
d、定时器
DemoTimmerTask.java 表面现象，也是离不开那两种方法
e、匿名内部类
AnonymousInnerClassDemo.java
f、Lambda表达式
Lambda.java

总结：多线程的实现方式，在代码种写法千变万化，但其本质万变不离其宗。
本质就是通过各种各样的包装，比如通过线程池包装、定时器包装，但是其本质都是那两种方式。

（*）面试问题：有多少种实现多线程的方式？
 答题思路，有以下5点：  
从不同的角度看，会有不同的答案。 典型答案是两种，分别是实现Runnable接口和继承Thread类；
但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，
run方法的代码如下： 
@Override 
public void run () {
    if (target != null) {
         target.run();
    }
}
方法一和方法二，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。
这两个方法的最主要区别在于run()方法的内容来源： 
方法一：最终调用target.run(); 方法二：run()整个都被重写；
然后具体展开说其他方式； 还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。  
结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现：第一种是重写run方法；
第二种实现Runnable接口的run方法，然后再把该runnable实例传给Thread类。
除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是它们的本质都逃不出刚才所说的范围。

2、怎样才是正确的线程启动方式？
2.1 start()和run()的比较
2.1.1 start()方法含义：
启动新线程————主线程会请求jvm运行线程，线程何时能运行由线程调度器决定。
start方法会让两个线程同时运行，第一个就是主线程，第二个才是刚刚创建的子线程；

准备工作————调用start()方法只是告诉jvm在合适的时候来启动；
第二个就是新线程需要准备工作才能运行，首先它会让自己处于就绪状态，
就绪状态指的是我已经获取到除CPU以外的其他资源，比如说我已经设置了上下文、栈、线程状态以及PC(寄存器，PC指向了程序运行的位置)；

不能重复调用start():
CantStartTwice.java

start方法的执行流程是什么？ 
1、检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中或者已结束的线程，都不能再次启动，详见CantStartTwice类）
2、被加入线程组 
3、调用start0()方法启动线程 
注意点： start方法是被synchronized修饰的方法，可以保证线程安全；
由JVM创建的main方法线程和system组线程，并不会通过start来启动。

2.1.2 run()方法：
那两种方式：“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”。

（*）面试问题：一个线程两次调用start()方法会出现什么情况？为什么？
start()方法开始的时候就会对当前线程的状态进行一个检查，如果不符合规定（如果已经执行了start()方法）就会抛出异常；
线程的状态：new状态 -> runnable -> 结束。

（*）面试问题：既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？
因为调用start()方法才是真正意义上启动一个线程，它会去经历线程的各个生命周期；
而如果直接调用run()方法，它就是一个普通的方法而已，不会通过子线程去调用。

2.2 start()方法原理解读

2.3 run()方法原理解读

2.4 面试问题

3、上山容易下山难————如何正确停止线程？（难点）

4、线程的一生————6个状态（生命周期）

5、Thread类和Object类中的重要方法详解

6、线程的各个属性

7、未捕获异常如何处理？

8、双刃剑：多线程会导致的问题